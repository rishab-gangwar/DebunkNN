# -*- coding: utf-8 -*-
"""SigmoidNeuron.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dkh6DVNHFa8Uq1M2tBJ57C3z4WF6-BPH
"""

import matplotlib.pyplot as plt
import numpy as np
import matplotlib.colors

def Sigmoid(x,w,b):
  return 1/(1+np.exp(-np.dot(w,x)-b))

w=1 #@param {type: "slider", min: -10, max: 10}
b=0  #@param {type: "slider", min: -10, max: 10}
X=np.linspace(-10,10,100)
Y=Sigmoid(X,w,b)
plt.plot(X,Y)
plt.show()

def Sigmoid2D(w1,w2,x1,x2,b):
  return 1/(1+np.exp(-(w1*x1+w2*x2+b)))

from mpl_toolkits import mplot3d

x1=np.linspace(-10,10,200)
x2=np.linspace(-10,10,200)
xx1,xx2=np.meshgrid(x1,x2)
print(x1.shape,xx1.shape,x2.shape,xx2.shape)

w1=.5
w2=.3
b=0
y=Sigmoid2D(w1,w2,xx1,xx2,b)
plt.contourf(xx1,xx2,y,cmap='viridis')
plt.show()
fig = plt.figure(figsize=(15,10))
ax = plt.axes(projection='3d')
ax.plot_surface(xx1,xx2,y,cmap='viridis')
ax.set_xlabel('x1')
ax.set_ylabel('x2')
m=46 #@param {type: "slider", min: 0, max: 180}
n=144 #@param {type: "slider", min: 0, max: 180}
ax.view_init(m,n)

def loss(X, Y, w_est, b_est):
  loss = 0
  for x, y in zip(X, Y):
    loss += (y - Sigmoid(x, w_est, b_est))**2
  return loss
W_u=.5
B_u=.25
X=np.random.random(25)*20-10
Y=Sigmoid(X,W_u,B_u)

w=np.linspace(-1,1,100)
b=np.linspace(-1,1,100)
WW,BB=np.meshgrid(w,b)
Loss=np.zeros(WW.shape)

for i in range(WW.shape[0]):
  for j in range(WW.shape[1]):
    Loss[i,j]=loss(X,Y,WW[i,j],BB[i,j])
fig = plt.figure(figsize=(15,10))
ax = plt.axes(projection='3d')
ax.plot_surface(WW,BB,Loss,cmap='viridis')
ax.set_xlabel('x1')
ax.set_ylabel('x2')
m=32 #@param {type: "slider", min: 0, max: 180}
n=54 #@param {type: "slider", min: 0, max: 180}
ax.view_init(m,n)

ij=np.argmin(Loss)

i=int(np.floor(ij/WW.shape[0]))
j=int(ij-i*WW.shape[0])

print(i,j)

WW[62,74]

BB[62,74]

"""# class sigmoid neuron"""

class SigmoidNeuron:
  def __init__(self):
    self.w=None
    self.b=None

  def perceptron(self,x):
    return np.dot(x,self.w.T) + self.b

  def sigmoid(self,x):
    return 1.0/(1.0+np.exp(-x))

  def grad_w(self,x,y):
    y_pred=self.sigmoid(self.perceptron(x))    
    return (y-y_pred)*(y_pred)*(1-y_pred)*x

  def grad_b(self,x,y):
    y_pred=self.sigmoid(self.perceptron(x))
    return (y-y_pred)*y_pred*(1-y_pred)

  def fit(self,X,Y,epochs,lr,intilize=True):
    if intilize:
      self.w=np.random.randn(1, X.shape[1])
      self.b = 0
    for i in range(epochs):
      dw=0
      db=0
      for x,y in zip(X,Y):
        dw+=self.grad_w(x,y)
        db+=self.grad_b(x,y)
      self.w-=lr*dw
      self.b-=lr*db

X=np.asarray([[2.5,2.5],[4,-1],[1,-4],[-3,1.25],[-2,-4],[1,5]])
Y=[1,1,1,0,0,0]

sn=SigmoidNeuron()
sn.fit(X,Y,1,.025,True)

for i in range(20):
  sn.fit(X,Y,1,.5,True)
  print(sn.w, sn.b)
  sn.fit(X,Y,1,.025,False)

my_cmap = mat\plotlib.colors.LinearSegmentedColormap.from_list("", ["red","yellow","green"])
def plot_sn(X,Y,sn,ax):
  x1=np.linspace(-10,10,300)
  x2=np.linspace(-10,10,300)
  xx1,xx2=np.meshgrid(x1,x2)
  yy=np.zeros(xx1.shape)
  for i in range(x2.size):
    for j in range(x1.size):
        val= np.asarray([x1[j],x2[i]])
        yy[i,j]=sn.sigmoid(sn.perceptron(val))
    ax.contour(xx1,xx2,yy,cmap=my_cmap,alpha = 0.6)
    ax.scatter(X[:,0],X[:,1],c=Y,cmap=my_cmap)
    ax.plot()

sn.fit(X,Y,1,.05,True)
plt.figure(figsize=(10,100))
for i in range(20):
  print(sn.w,sn.b)
  ax=plt.subplot(20,1,i+1)
  plot_sn(X,Y,sn,ax)
  sn.fit(X,Y,1,.75,False)



!wget https://www.dropbox.com/s/739uo8ebwbic9kb/mobile_cleaned.csv

